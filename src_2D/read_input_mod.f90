module read_input_module

  ! -----------------------------------------------------------------
  ! This module is used to read the input file. When reading the
  ! input file it is important to realize that there are two type of
  ! variables:
  !
  ! 1) Variables that are used by amrex to generate the mesh.
  !    These variables are labelled with "amr" and with 
  !    "geometry" in the input file. The value of such
  !     variables is read from the amrex initialization routines
  !    so in the following module they are used only
  !    to ensure self-consistency of the input.
  !
  !    Among these variables, the following must be specified:
  !     a) geometry.prob_lo: Coordinates of the bottom-left corner of
  !                          the domain (x,y)
  !     b) geometry.prob_hi: Coordinates of the top-right corner of
  !                          the domain (x,y)
  !     c) amr.n_cell: Number of cells in each direction (x,y)
  !     d) amr.max_level: Maximum amrex level (starting from 0)
  !
  !    The following can be omitted, in which case they will
  !    assume the default value:
  !     a) amr.v (default: 0)
  !     b) amr.ref_ratio (default: 2 for each level)
  !     c) amr.blocking_factor (default: 8)
  !     d) amr.max_grid_size (default: 32)
  !
  ! 2) Variables that are used from the rest of the code. Such
  !    variables have a diverse set of labels and are read
  !    by the routine specified in this module. All these
  !    variables are optional, if not specified they will
  !    be assigned the values given in set_default_values
  ! -----------------------------------------------------------------
  
  use amrex_amr_module
  use amrex_linear_solver_module
  
  implicit none 

  private

  ! -----------------------------------------------------------------
  ! Public variables (read from input file)
  ! -----------------------------------------------------------------

  ! --- Variables that control the length of the simulation ---

  ! Time step [s]
  public :: in_dt
  ! Maximum number of time steps
  public :: max_step  
  ! Maximum simulated time [s]
  public :: stop_time


  ! --- Variables for the geometry of the heat transfer domain ---

  ! Select type of geometry to simulate (Slab, West or West_rectangular)
  public :: geometry_name
  ! West geometry: Coordinates for the center of the cooling pipe 
  public :: cool_pipe_cntr
  ! West geometry: Radius of the cooling pipe
  public :: cool_pipe_radius

  ! --- Variables that control the grid generated by amrex ---

  ! How often to check if regrid is necessary (in number of time steps)
  public :: regrid_int
  ! Distance from the free surface that triggers regridding. One value
  ! for each level larger than 0 must be provided
  public :: surfdist

  ! --- Variables for the heat solver ---

  ! Parameters to plot the cooling fluxes as a function of
  ! the temperature. Array with 5 elements: 1) on-off switch,
  ! with 1 = on and 0 = off, 2) minimum temperature
  ! 3) maximum temperature, 4) temperature resolution
  ! 5) incoming heat flux
  public :: cooling_debug
  ! Activate or deactivate thermionic cooling (1 = on, 0 = off)
  public :: cooling_thermionic
  ! Activate or deactivate vaporization cooling (1 = on, 0 = off)
  public :: cooling_vaporization
  ! Activate or deactivate radiative cooling (1 = on, 0 = off)
  public :: cooling_radiation
  ! Prescribe fixed melt velocity
  public :: fixed_melt_velocity
  ! Solver for the heat equation (explicit or implicit)
  public :: heat_solver
  ! Inclination of the magnetic field
  public :: magnetic_inclination
  ! Initial phase of the sample (solid, liquid). Relevant only
  ! if the sample is initialized at the melting temperature
  public :: phase_init
  ! Type of plasma heat flux (Gaussian, Uniform, Input_file)
  public :: plasma_flux_type
  ! Parameters for the plasma heat flux. An array with 5 parameters
  ! whose content depends on the type of plasma heat flux
  !  a) Gaussian heat flux, array with 5 elements: 1) switching on,
  !     time, 2) switching off time, 3) peak magnitude,
  !     4) peak position, 5) standard deviation
  !  b) Uniform heat flux, array with 5 elements: 1) switching on,
  !     time, 2) switching off time, 3) magnitude,
  !     4) minimum x coordinate, 5) maximum x coordinate
  public :: plasma_flux_params
  ! Name of file containing the plasma flux (used only if the plasma
  ! heat flux is of type Input_file)
  public :: plasma_flux_input_file
  ! Type of plasma heat flux on the second exposed side for the
  ! West geometry (Gaussian, Uniform, Input_file)
  public :: plasma_flux_side_type
  ! Parameters for the plasma heat flux on the second exposed side
  ! for the West geometry. Analogous to plasma_flux_parameters
  public :: plasma_flux_side_params
  ! Name of file containing the plasma flux on the second exposed
  ! side for the West geometry (Used only if the plasma
  ! heat flux is of type Input_file)
  public :: plasma_flux_side_input_file
  ! Edge of the simulation domain along the x direction
  public :: sample_edge
  ! Solve the heat equation (1 = yes, 0 = no) 
  public :: solve_heat
  ! Initial position of the free surface (assumed perpendicular to y)
  public :: surf_pos_init
  ! Impose temperature on the free surface (only used if positive)
  public :: temp_fs
  ! Initial uniform temperature of the sample
  public :: temp_init


  ! --- Variables for the linear solvers ---

  ! These variables are used only if the heat solver is implicit

  ! Relative error used in the linear solvers
  public :: ls_accuracy
  ! Internal parameters for the linear solvers
  public :: ls_composite_solve
  public :: ls_verbose
  public :: ls_bottom_verbose
  public :: ls_max_iter
  public :: ls_max_fmg_iter
  public :: ls_bottom_solver
  public :: ls_linop_maxorder
  public :: ls_agglomeration
  public :: ls_consolidation
  public :: ls_max_coarsening_level


  ! --- Variables for the shallow water solver ---

  ! Solve the shallow water equation (1 = yes, 0 = no) 
  public :: solve_sw
  ! Solve the momentum equation (1 = yes, 0 = no). If the momentum
  ! equation is not solved, the velocity is assumed to be equal to
  ! the velocity prescribed with heat.fixed_melt_velocity
  public :: sw_solve_momentum
  ! Magnitude of the magnetic field [T]
  public :: sw_magnetic
  ! Capping height for the viscous drag in the momentum equation [m]
  public :: sw_captol
  ! Dry tolerance for the melt pool (any height below dry tolerance
  ! is assumed to be zero)
  public :: sw_drytol
  ! Thermionic current on the free surface. An array of 3 elements
  ! containing: 1) the magnitude of the current, 2) the switching on
  ! time, 3) the switching off time. This is only used if the
  ! heat equation is not solved
  public :: sw_current
  ! Parameters used to generate a gaussian pool if the heat equation
  ! is not solved. An array with 3 elements containing: 1) The
  ! maximum depth of the pool, 2) the position of the center of the
  ! pool, 3) the width of the pool (as a standard deviation)
  public :: sw_pool_params

  
  ! --- Variables for the material properties ---

  ! Type of material to simulated, only one can be selected (Tungsten,
  ! Beryllium, Iridium, Niobium)
  public :: material
  ! Maximum temperature used to compute the material properties
  public :: phiT_table_max_T
  ! Number of temperatures at which the material properties are computed
  public :: phiT_table_n_points

  ! --- Variables for the input/output ---

  ! Name of the restart files written by amrex
  public :: check_file
  ! Name of the plot files written by amrex
  public :: plot_file
  ! How often to write restart files (in time steps)
  public :: check_int
  ! How often to write output to files (in time steps)
  public :: plot_int
  ! Name of file use to restart the simulation
  public :: restart
  ! Verbosity of the code (1 = on, 0 = off)
  public :: verbose
  
  ! --- Parameters that control the numerical solutions ---

  ! Safety factor used to multiply the minimum time step
  ! that ensures the stability of the heat solver
  public :: cfl
  ! Activate or deactivate reflux in the explicit heat
  ! solver (1 = on, 0 = off)
  public :: do_reflux
  ! Maximum fractional change of the timestep between two
  ! successive timesteps
  public :: dt_change_max

  
  ! -----------------------------------------------------------------
  ! Public subroutines
  ! -----------------------------------------------------------------
  public :: read_input_file, deallocate_input

  ! -----------------------------------------------------------------
  ! Declare public variables
  ! -----------------------------------------------------------------
  character(len=:), allocatable, save :: check_file
  character(len=:), allocatable, save :: material
  character(len=:), allocatable, save :: geometry_name
  character(len=:), allocatable, save :: heat_solver
  character(len=:), allocatable, save :: plasma_flux_type
  character(len=:), allocatable, save :: plasma_flux_input_file
  character(len=:), allocatable, save :: plasma_flux_side_type
  character(len=:), allocatable, save :: plasma_flux_side_input_file
  character(len=:), allocatable, save :: phase_init
  character(len=:), allocatable, save :: plot_file
  character(len=:), allocatable, save :: restart   
  integer, save :: check_int
  integer, save :: ls_verbose
  integer, save :: ls_bottom_verbose
  integer, save :: ls_max_iter
  integer, save :: ls_max_fmg_iter
  integer, save :: ls_bottom_solver
  integer, save :: ls_linop_maxorder
  integer, save :: ls_max_coarsening_level
  integer, save :: max_step
  integer, save :: phiT_table_n_points
  integer, save :: plot_int
  integer, save :: regrid_int
  integer, save :: verbose
  logical, save :: cooling_thermionic
  logical, save :: cooling_vaporization
  logical, save :: cooling_radiation
  logical, save :: do_reflux
  logical, save :: ls_composite_solve  
  logical, save :: ls_agglomeration
  logical, save :: ls_consolidation
  logical, save :: solve_sw
  logical, save :: solve_heat
  logical, save :: sw_solve_momentum
  real(amrex_real), save :: cfl
  real(amrex_real), save :: cool_pipe_radius
  real(amrex_real), save :: dt_change_max
  real(amrex_real), save :: in_dt  
  real(amrex_real), save :: fixed_melt_velocity
  real(amrex_real), save :: ls_accuracy
  real(amrex_real), save :: magnetic_inclination
  real(amrex_real), save :: phiT_table_max_T
  real(amrex_real), save :: stop_time
  real(amrex_real), save :: surf_pos_init
  real(amrex_real), save :: sample_edge
  real(amrex_real), save :: sw_captol
  real(amrex_real), save :: sw_drytol
  real(amrex_real), save :: sw_magnetic
  real(amrex_real), save :: temp_fs
  real(amrex_real), save :: temp_init
  real(amrex_real), allocatable, save :: cooling_debug(:)
  real(amrex_real), allocatable, save :: cool_pipe_cntr(:)
  real(amrex_real), allocatable, save :: plasma_flux_params(:)
  real(amrex_real), allocatable, save :: plasma_flux_side_params(:)
  real(amrex_real), allocatable, save :: surfdist(:)
  real(amrex_real), allocatable, save :: sw_current(:)
  real(amrex_real), allocatable, save :: sw_pool_params(:)
  
contains

  ! ------------------------------------------------------------------
  ! Subroutine used to read the input file. Note: part of the input
  ! file is also read by the amrex initialization routines invoked
  ! with amrex_init (see the initialization module)
  ! ------------------------------------------------------------------
  subroutine read_input_file()

    type(amrex_parmparse) :: pp

    ! Default parameters
    call set_default_values

    ! Parameters for the simulation length and timestep
    call amrex_parmparse_build(pp, "length")
    call pp%query("max_step", max_step)
    call pp%query("stop_time", stop_time)
    call pp%query("dt", in_dt)
    call amrex_parmparse_destroy(pp)

    ! Parameters for the grid control
    call amrex_parmparse_build(pp, "grid")
    call pp%query("regrid_int", regrid_int)
    call pp%queryarr("surfdist", surfdist)
    call amrex_parmparse_destroy(pp)

    ! Parameters for the output
    call amrex_parmparse_build(pp, "output")
    call pp%query("check_int", check_int)
    call pp%query("plot_int", plot_int)
    call pp%query("check_file", check_file)
    call pp%query("plot_file", plot_file)
    call pp%query("verbose", verbose)
    call amrex_parmparse_destroy(pp)

    ! Parameters for the restart
    call amrex_parmparse_build(pp, "restart")
    call pp%query("restart", restart)
    call amrex_parmparse_destroy(pp)
   
    ! Parameters for the heat solver
    call amrex_parmparse_build(pp, "heat")
    call pp%query("surf_pos", surf_pos_init) 
    call pp%query("solve", solve_heat)  
    call pp%query("fixed_melt_velocity", fixed_melt_velocity)  
    call pp%query("surf_pos", surf_pos_init)
    call pp%query("sample_edge", sample_edge) 
    call pp%query("temp_init", temp_init)
    call pp%query("phase_init", phase_init)
    call pp%query("plasma_flux_type", plasma_flux_type) 
    call pp%queryarr("plasma_flux_params", plasma_flux_params)
    call pp%query("plasma_side_flux_type", plasma_flux_side_type) 
    call pp%queryarr("plasma_side_flux_params", plasma_flux_side_params)
    call pp%query("plasma_flux_input_file", plasma_flux_input_file)
    call pp%query("plasma_side_flux_input_file", plasma_flux_side_input_file)
    call pp%query("temp_free_surface", temp_fs)
    call pp%query("cooling_thermionic",cooling_thermionic)
    call pp%query("cooling_vaporization",cooling_vaporization)
    call pp%query("cooling_radiation",cooling_radiation)
    call pp%queryarr("cooling_debug",cooling_debug)
    call pp%query("magnetic_inclination",magnetic_inclination)
    call pp%query("heat_solver",heat_solver)
    call amrex_parmparse_destroy(pp)
    
    ! Parameters for the shallow water solver
    call amrex_parmparse_build(pp, "sw")
    call pp%query("solve", solve_sw)
    call pp%query("solve_momentum", sw_solve_momentum)
    call pp%query("magnetic", sw_magnetic)
    call pp%query("captol", sw_captol)
    call pp%query("drytol", sw_drytol)
    call pp%queryarr("current", sw_current)
    call pp%queryarr("pool_params", sw_pool_params)
    call amrex_parmparse_destroy(pp)

    ! Parameters for the material
    call amrex_parmparse_build(pp, "material")
    call pp%query("material", material)
    call pp%query("phiT_max_T", phiT_table_max_T)
    call pp%query("phiT_n_points", phiT_table_n_points)
    call amrex_parmparse_destroy(pp)

    ! Parameters for the geometry
    call amrex_parmparse_build(pp, "geometry")
    call pp%query("geometry_name", geometry_name)
    call pp%queryarr("cool_pipe_cntr",cool_pipe_cntr)
    call pp%query("cool_pipe_radius", cool_pipe_radius)
    call amrex_parmparse_destroy(pp)
    
    ! Parameters for the numerics
    call amrex_parmparse_build(pp, "numerics")
    call pp%query("cfl", cfl)
    call pp%query("do_reflux", do_reflux)
    call pp%query("dt_change_max", dt_change_max)
    call amrex_parmparse_destroy(pp)

    ! Parameters for the linear solver used for the implicit solution of the heat equation
    call amrex_parmparse_build(pp, "linear_solver")
    call pp%query("accuracy", ls_accuracy)
    call pp%query("composite_solve", ls_composite_solve)
    call pp%query("verbose", ls_verbose)
    call pp%query("bottom_verbose_ls", ls_bottom_verbose)
    call pp%query("max_iter", ls_max_iter)
    call pp%query("max_fmg_iter", ls_max_fmg_iter)
    call pp%query("bottom_solver", ls_bottom_solver)
    call pp%query("linop_maxorder", ls_linop_maxorder)
    call pp%query("agglomeration", ls_agglomeration)
    call pp%query("consolidation", ls_consolidation)
    call pp%query("max_coarsening_level", ls_max_coarsening_level)
    
  end subroutine read_input_file


  ! Default values for the input parameters
  subroutine set_default_values()

    integer :: i
        
    allocate(character(len=3)::check_file)
    allocate(character(len=8)::heat_solver)
    allocate(character(len=8)::plasma_flux_type)
    allocate(character(len=8)::plasma_flux_side_type)
    allocate(character(len=25)::plasma_flux_input_file)
    allocate(character(len=25)::plasma_flux_side_input_file)
    allocate(character(len=8)::material)
    allocate(character(len=4)::geometry_name)
    allocate(character(len=9)::phase_init)
    allocate(character(len=3)::plot_file)
    allocate(character(len=0)::restart)
    allocate(cooling_debug(5))
    allocate(cool_pipe_cntr(2))
    allocate(plasma_flux_params(100))
    allocate(plasma_flux_side_params(100))
    allocate(surfdist(0:amrex_max_level))
    allocate(sw_current(3))
    allocate(sw_pool_params(3))
    
    cfl = 0.70
    check_file = "chk"
    check_int = -1
    cooling_debug(1) = 0
    cooling_debug(2) = 300
    cooling_debug(3) = 301
    cooling_debug(4) = 1
    cooling_debug(5) = 1e6
    cooling_thermionic = .true.
    cooling_vaporization = .true.
    cooling_radiation = .true.
    do_reflux = .true.
    dt_change_max = 1.1
    in_dt = 0.0001
    fixed_melt_velocity = 0.0
    heat_solver = "explicit"
    ls_accuracy = 10e-10
    ls_composite_solve = .true.
    ls_verbose = 1
    ls_bottom_verbose = 0
    ls_max_iter = 100
    ls_max_fmg_iter = 0
    ls_bottom_solver = amrex_bottom_default
    ls_linop_maxorder = 2
    ls_agglomeration = .true.
    ls_consolidation = .true.
    ls_max_coarsening_level = 30
    material = "Tungsten"
    geometry_name = "Slab"
    cool_pipe_cntr(1) = 0.01
    cool_pipe_cntr(2) = 0.005
    cool_pipe_radius = 0.0
    max_step = 10000
    phase_init = "undefined"
    phiT_table_max_T = 10000.0
    phiT_table_n_points = 10000
    plasma_flux_params(1) = 0.0
    plasma_flux_params(2) = 1.0
    plasma_flux_params(3) = 300e6
    plasma_flux_params(4) = 0.0
    plasma_flux_params(5) = 0.01
    plasma_flux_side_params(1) = 0.0
    plasma_flux_side_params(2) = 1.0
    plasma_flux_side_params(3) = 300e6
    plasma_flux_side_params(4) = 0.0
    plasma_flux_side_params(5) = 0.01
    plasma_flux_type = "Gaussian"
    plasma_flux_side_type = "Gaussian"
    plasma_flux_input_file = "plasma_flux.dat"
    plasma_flux_side_input_file = "plasma_side_flux.dat"
    plot_file = "plt"
    plot_int = -1
    regrid_int = 2
    solve_heat = .false.
    solve_sw = .true.
    sw_solve_momentum = .true.
    sw_magnetic = 0.0
    sw_captol = 0.0
    sw_current = 0.0
    sw_drytol = 0.0
    sw_pool_params(1) = 0.0
    sw_pool_params(2) = 0.0
    sw_pool_params(3) = 1.0
    stop_time = 1.0
    do i = 0, amrex_max_level
       surfdist(i) = 0.0
    end do
    surf_pos_init = 0.020
    sample_edge = 0.020
    magnetic_inclination = 90.0
    temp_fs = -1.0
    verbose = 0
    
  end subroutine set_default_values

  ! ------------------------------------------------------------------
  ! Subroutine used to free the memory related to the input variables
  ! ------------------------------------------------------------------  
  subroutine deallocate_input()
    
    deallocate(check_file)
    deallocate(heat_solver)
    deallocate(material)
    deallocate(geometry_name)
    deallocate(phase_init)
    deallocate(plasma_flux_params)
    deallocate(plasma_flux_type)
    deallocate(plasma_flux_side_type)
    deallocate(plasma_flux_input_file)
    deallocate(plasma_flux_side_input_file)
    deallocate(plot_file)
    deallocate(restart)
    deallocate(surfdist)
    deallocate(sw_current)
    deallocate(sw_pool_params)
    
  end subroutine deallocate_input
    
end module read_input_module
